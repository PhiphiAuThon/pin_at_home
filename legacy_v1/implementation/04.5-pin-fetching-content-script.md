# Phase 4.5: Pin Fetching via Content Script Injection (Private Boards)

## Overview

This phase implements pin fetching for **private/secret boards** using a content script injection approach. Since Pinterest's API blocks requests from browser extensions for private boards, we need to run code directly on the Pinterest page itself.

---

## Why This Approach?

**The Problem:**
- Pinterest API returns 403 (Forbidden) for private board requests from extensions
- Even with CSRF tokens and session cookies, the `chrome-extension://` origin is blocked
- Private boards have extra security that only allows access from `pinterest.com` origin

**The Solution:**
- Open board pages in hidden tabs
- Inject content scripts that run WITH Pinterest's origin
- Extract pin data from the DOM/page context
- Send data back to background script
- Clean up tabs

---

## Architecture

```
User Opens New Tab
    ‚Üì
Background Script
    ‚Üì
Creates Hidden Tab ‚Üí Opens Board URL
    ‚Üì
Content Script Injected (runs on Pinterest page)
    ‚Üì
Extracts Pins from DOM/API
    ‚Üì
Sends Data Back via Message
    ‚Üì
Background Receives Pins
    ‚Üì
Closes Hidden Tab
    ‚Üì
Returns Pins to New Tab
```

---

## Step 4.5.1: Update Manifest Permissions

**File: `manifest.json`**

Add content script and tabs permissions:

```json
{
  "manifest_version": 3,
  "name": "Pinterest Random Pins",
  "version": "1.0.0",
  "description": "Display random pins from your private Pinterest boards on every new tab",
  "permissions": [
    "storage",
    "identity",
    "cookies",
    "tabs",
    "scripting"
  ],
  "host_permissions": [
    "https://api.pinterest.com/*",
    "https://www.pinterest.com/*"
  ],
  "background": {
    "service_worker": "background.js"
  },
  "content_scripts": [
    {
      "matches": ["https://www.pinterest.com/*"],
      "js": ["content-scripts/pin-extractor.js"],
      "run_at": "document_idle"
    }
  ],
  "chrome_url_overrides": {
    "newtab": "newtab/newtab.html"
  },
  "action": {
    "default_popup": "settings/settings.html",
    "default_icon": {
      "16": "assets/icons/icon16.png",
      "48": "assets/icons/icon48.png",
      "128": "assets/icons/icon128.png"
    }
  },
  "options_ui": {
    "page": "settings/settings.html",
    "open_in_tab": true
  },
  "icons": {
    "16": "assets/icons/icon16.png",
    "48": "assets/icons/icon48.png",
    "128": "assets/icons/icon128.png"
  },
  "content_security_policy": {
    "extension_pages": "script-src 'self'; object-src 'self'"
  }
}
```

**Changes:**
- Added `"tabs"` permission
- Added `"scripting"` permission
- Added `content_scripts` entry

---

## Step 4.5.2: Create Content Script Pin Extractor

**File: `content-scripts/pin-extractor.js`**

Create a new directory and file:

```javascript
// Pin Extractor Content Script
// Runs on Pinterest pages with pinterest.com origin
// Can access DOM and make API calls as if it's the real Pinterest site

console.log('üìå Pinterest Pin Extractor loaded');

// Listen for messages from background script
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === 'extractPins') {
    console.log('üîç Extracting pins from current page...');
    extractPinsFromPage(request.boardUrl)
      .then(pins => {
        console.log(`‚úÖ Extracted ${pins.length} pins`);
        sendResponse({ success: true, pins: pins });
      })
      .catch(error => {
        console.error('‚ùå Error extracting pins:', error);
        sendResponse({ success: false, error: error.message });
      });
    
    return true; // Keep channel open for async response
  }
});

/**
 * Extract pins from the current Pinterest board page
 * @param {string} boardUrl - Board URL for verification
 * @returns {Promise<Array>} List of pin objects
 */
async function extractPinsFromPage(boardUrl) {
  // Wait for page to fully load
  await waitForPageLoad();
  
  const pins = [];
  
  // Method 1: Try to get pins from __PWS_DATA__ (if available)
  const pwsPins = extractFromPwsData();
  if (pwsPins.length > 0) {
    console.log(`üìä Found ${pwsPins.length} pins in __PWS_DATA__`);
    pins.push(...pwsPins);
  }
  
  // Method 2: Try to get pins from Redux store (Pinterest uses Redux)
  const reduxPins = extractFromReduxStore();
  if (reduxPins.length > 0) {
    console.log(`üî¥ Found ${reduxPins.length} pins in Redux store`);
    pins.push(...reduxPins);
  }
  
  // Method 3: Fallback to DOM scraping  
  if (pins.length === 0) {
    console.log('‚ö†Ô∏è Trying DOM scraping as fallback...');
    const domPins = await extractFromDOM();
    pins.push(...domPins);
  }
  
  // Deduplicate
  const uniquePins = Array.from(
    new Map(pins.map(p => [p.id, p])).values()
  );
  
  return uniquePins;
}

/**
 * Wait for page to be fully loaded
 */
function waitForPageLoad() {
  return new Promise((resolve) => {
    if (document.readyState === 'complete') {
      resolve();
    } else {
      window.addEventListener('load', resolve);
    }
  });
}

/**
 * Extract pins from __PWS_DATA__ script tag
 */
function extractFromPwsData() {
  const pins = [];
  
  try {
    const script = document.getElementById('__PWS_DATA__');
    if (!script) return pins;
    
    const data = JSON.parse(script.textContent);
    
    // Search recursively for pin objects
    function searchPins(obj, depth = 0) {
      if (depth > 10) return;
      if (!obj || typeof obj !== 'object') return;
      
      if (obj.type === 'pin' && obj.id && obj.images) {
        const images = obj.images;
        const imageUrl = images.orig?.url || 
                        images['1200x']?.url || 
                        images['736x']?.url ||
                        images['600x']?.url;
        
        if (imageUrl) {
          pins.push({
            id: obj.id,
            title: obj.title || obj.grid_title || '',
            description: obj.description || '',
            link: obj.link || `https://www.pinterest.com/pin/${obj.id}/`,
            imageUrl: imageUrl,
            dominantColor: obj.dominant_color || '#2a2a2a'
          });
        }
      }
      
      if (Array.isArray(obj)) {
        obj.forEach(item => searchPins(item, depth + 1));
      } else {
        Object.values(obj).forEach(val => searchPins(val, depth + 1));
      }
    }
    
    searchPins(data);
  } catch (error) {
    console.warn('Could not extract from PWS data:', error);
  }
  
  return pins;
}

/**
 * Extract pins from window Redux store (Pinterest uses Redux)
 */
function extractFromReduxStore() {
  const pins = [];
  
  try {
    // Pinterest stores data in window.__REDUX_STATE__ or similar
    // Try common locations
    const reduxState = window.__REDUX_STATE__ || 
                       window.__INITIAL_STATE__ ||
                       window.reduxStore?.getState();
    
    if (!reduxState) return pins;
    
    // Look for pins in the state
    if (reduxState.pins) {
      Object.values(reduxState.pins).forEach(pin => {
        if (pin.id && pin.images) {
          const images = pin.images;
          const imageUrl = images.orig?.url || 
                          images['1200x']?.url || 
                          images['600x']?.url;
          
          if (imageUrl) {
            pins.push({
              id: pin.id,
              title: pin.title || pin.grid_title || '',
              description: pin.description || '',
              link: pin.link || `https://www.pinterest.com/pin/${pin.id}/`,
              imageUrl: imageUrl,
              dominantColor: pin.dominant_color || '#2a2a2a'
            });
          }
        }
      });
    }
  } catch (error) {
    console.warn('Could not extract from Redux:', error);
  }
  
  return pins;
}

/**
 * Extract pins from DOM elements (fallback method)
 */
async function extractFromDOM() {
  const pins = [];
  
  try {
    // Wait a bit for lazy-loaded content
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Find pin elements (Pinterest uses data-test-id)
    const pinElements = document.querySelectorAll('[data-test-id="pin"]');
    
    pinElements.forEach(el => {
      try {
        const link = el.querySelector('a[href*="/pin/"]');
        if (!link) return;
        
        const pinId = link.href.match(/\/pin\/(\d+)\//)?.[1];
        if (!pinId) return;
        
        const img = el.querySelector('img');
        if (!img || !img.src) return;
        
        const title = img.alt || el.querySelector('h3')?.textContent || '';
        
        pins.push({
          id: pinId,
          title: title,
          description: '',
          link: `https://www.pinterest.com/pin/${pinId}/`,
          imageUrl: img.src,
          dominantColor: '#2a2a2a'
        });
      } catch (error) {
        console.warn('Error parsing pin element:', error);
      }
    });
  } catch (error) {
    console.warn('Could not extract from DOM:', error);
  }
  
  return pins;
}
```

---

## Step 4.5.3: Create Hidden Tab Pin Fetcher

**File: `api/hidden-tab-fetcher.js`**

```javascript
// Hidden Tab Pin Fetcher
// Opens Pinterest boards in hidden tabs and extracts pins via content scripts

/**
 * Fetch pins from a board using hidden tab + content script
 * @param {string} boardUrl - Board URL path (e.g., /username/board/)
 * @returns {Promise<Array>} List of pins
 */
async function fetchPinsViaHiddenTab(boardUrl) {
  let tabId = null;
  
  try {
    console.log(`üì• Opening hidden tab for: ${boardUrl}`);
    
    // Create hidden tab
    const tab = await chrome.tabs.create({
      url: `https://www.pinterest.com${boardUrl}`,
      active: false // Hidden/background tab
    });
    
    tabId = tab.id;
    console.log(`‚úÖ Created tab ${tabId}`);
    
    // Wait for tab to load
    await waitForTabLoad(tabId);
    console.log(`‚úÖ Tab loaded`);
    
    // Give Pinterest a moment to render
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Send message to content script to extract pins
    const response = await chrome.tabs.sendMessage(tabId, {
      action: 'extractPins',
      boardUrl: boardUrl
    });
    
    // Close the tab
    await chrome.tabs.remove(tabId);
    console.log(`‚úÖ Closed tab ${tabId}`);
    
    if (response.success) {
      console.log(`‚úÖ Got ${response.pins.length} pins from hidden tab`);
      return response.pins;
    } else {
      throw new Error(response.error || 'Failed to extract pins');
    }
    
  } catch (error) {
    // Clean up tab if it exists
    if (tabId) {
      try {
        await chrome.tabs.remove(tabId);
      } catch {}
    }
    
    console.error(`‚ùå Error fetching via hidden tab:`, error);
    return [];
  }
}

/**
 * Wait for tab to finish loading
 */
function waitForTabLoad(tabId) {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error('Tab load timeout'));
    }, 15000);
    
    function checkStatus() {
      chrome.tabs.get(tabId, (tab) => {
        if (chrome.runtime.lastError) {
          clearTimeout(timeout);
          reject(chrome.runtime.lastError);
          return;
        }
        
        if (tab.status === 'complete') {
          clearTimeout(timeout);
          resolve();
        } else {
          setTimeout(checkStatus, 100);
        }
      });
    }
    
    checkStatus();
  });
}

/**
 * Fetch pins from multiple boards
 */
async function fetchPinsFromBoards(boardUrls, count = 25) {
  console.log(`üé≤ Fetching pins from ${boardUrls.length} boards...`);
  
  const allPins = [];
  
  // Fetch boards one at a time (avoid opening too many tabs)
  for (const boardUrl of boardUrls) {
    const pins = await fetchPinsViaHiddenTab(boardUrl);
    allPins.push(...pins);
  }
  
  console.log(`üìå Total pins collected: ${allPins.length}`);
  
  // Shuffle and select
  const shuffled = allPins.sort(() => Math.random() - 0.5);
  const selected = shuffled.slice(0, count);
  
  // Cache
  if (self.StorageUtils) {
    await StorageUtils.cachePins(selected);
  }
  
  return selected;
}

// Export
const HiddenTabFetcher = {
  fetchPinsFromBoards,
  fetchPinsViaHiddenTab
};

if (typeof self !== 'undefined') {
  self.HiddenTabFetcher = HiddenTabFetcher;
}

console.log('‚úÖ HiddenTabFetcher loaded');
```

---

## Step 4.5.4: Update Background Script

**File: `background.js`**

Replace the pin-fetcher import with hidden-tab-fetcher:

```javascript
// Import dependencies
importScripts('utils/storage.js');
importScripts('auth/session-manager.js');
importScripts('api/manual-board-manager.js');
importScripts('api/hidden-tab-fetcher.js'); // NEW: Use hidden tab fetcher

// ... rest of background.js ...

// Update fetchPins handler
case 'fetchPins':
  HiddenTabFetcher.fetchPinsFromBoards(request.boardUrls, request.count)
    .then(pins => sendResponse({ success: true, data: pins }))
    .catch(error => sendResponse({ success: false, error: error.message }));
  return true;
```

---

## ‚úÖ Testing

### Test 1: Basic Pin Fetch
1. Reload extension
2. Open new tab
3. Watch for hidden tab to briefly appear/disappear
4. Check console for pin extraction logs

### Test 2: Private Board
1. Use a private/secret board
2. Should work now that we're running on Pinterest's page

### Test 3: Multiple Boards
1. Select multiple boards
2. Should open each board in sequence

---

## ‚ö†Ô∏è Known Limitations

1. **Slower**: Opens real tabs (takes 2-3 seconds per board)
2. **Visible**: User might see tabs briefly flash
3. **Rate Limiting**: Don't fetch too many boards at once

---

## üí° Optimizations

To make this faster in the future:
- Use offscreen documents (Manifest V3 feature)
- Cache pins longer
- Fetch in background periodically

---

## üéâ Advantages

- ‚úÖ Works with private boards
- ‚úÖ Works with secret boards
- ‚úÖ No API restrictions
- ‚úÖ Same data as real Pinterest page
- ‚úÖ More reliable long-term

---

Ready to implement! This approach should work with your private boards. üöÄ
